import tkinter as tk
from PIL import Image, ImageTk, ImageSequence
import queue

base_path = r"C:\Users\user\Downloads\hand_gifs"

def write_to_file(tk_entry, variable, value_type):
    try:
        value = tk_entry.get()
        
        # Convert the value to the appropriate type
        if value_type == 'float':
            value = float(value)
        elif value_type == 'bool':
            value = value.lower() in ['true', '1', 'yes']
        
        # Read the current content of config.txt
        with open("config.txt", "r") as file:
            lines = file.readlines()
        
        # Update the value
        for i, line in enumerate(lines):
            if line.startswith(variable):
                if value_type == 'string':
                    lines[i] = f'{variable} = "{value}"\n'
                else:
                    lines[i] = f'{variable} = "{value}"\n'
                break
        else:
            # If the variable is not found, append it
            if value_type == 'string':
                lines.append(f'{variable} = "{value}"\n')
            else:
                lines.append(f'{variable} = "{value}"\n')
        
        # Write the updated content back to config.txt
        with open("config.txt", "w") as file:
            file.writelines(lines)
        
        messagebox.showinfo("Success", f'{variable} value written to config.txt')
    except ValueError:
        messagebox.showerror("Error", "Please enter a valid value")

class VideoPlayer:
    def __init__(self, parent_frame, gif_path, window):
        self.parent_frame = parent_frame
        self.window = window
        self.gif_path = gif_path

        self.label = tk.Label(parent_frame)
        self.label.place(x=0, y=0, width=window.winfo_screenwidth()//2, height=window.winfo_screenheight()//2)

        self.frames = self.load_gif_frames(gif_path)
        self.frame_index = 0
        self.playing = True
        self.update_frame()

    def load_gif_frames(self, path):
        gif = Image.open(path)
        frames = [ImageTk.PhotoImage(frame.copy().convert('RGB')) for frame in ImageSequence.Iterator(gif)]
        return frames

    def set_path(self, path):
        self.gif_path = path
        self.frames = self.load_gif_frames(self.gif_path)
        self.frame_index = 0
        self.playing = True
        self.update_frame()

    def update_frame(self):
        if not self.playing:
            return

        if self.frame_index < len(self.frames):
            frame = self.frames[self.frame_index]
            self.label.imgtk = frame
            self.label.configure(image=frame)
            self.frame_index += 1
            self.parent_frame.after(100, self.update_frame)  # Adjust the delay as needed
        else:
            self.playing = False

    def stop(self):
        self.playing = False

def populate_queue(text_queue, wordBacklog):
    for _ in range(10):
        formatted_text = format_text(wordBacklog)
        text_queue.put(formatted_text)

def format_text(wordBacklog):
    lines = []
    for i in range(0, len(wordBacklog), 5):
        line = ' '.join(wordBacklog[i:i+5])
        lines.append(line)
    updated_text = '\n'.join(lines)
    return updated_text

def update_letter(hand_queue):
    if hand_queue in 'abcdefghijklmnopqrstuvwxyz':
        return fr"{base_path}\{hand_queue.upper()}.gif"
    else:
        return fr"{base_path}\open_palm.gif"

def set_config_variables(lettersPause, wordPause, exitWord, autoSave, autoLaunch):
    write_to_file(lettersPause, "lettersPause", "float")
    write_to_file(wordPause, "wordsPause", "float")
    write_to_file(exitWord, "exitWord", "string")
    write_to_file(autoSave, "autoSave", "bool")
    write_to_file(autoLaunch, "autoLaunch", "bool")

def GUI(text_queue, hand_queue, letter_queue, wordBacklog):

    window = tk.Tk()
    window.geometry('%dx%d+0+0' % (window.winfo_screenwidth(), window.winfo_screenheight()))
    window.title("GUI")

    # Define the exact dimensions and positions for frames
    window_width = window.winfo_screenwidth()
    window_height = window.winfo_screenheight()

    video_frame = tk.Frame(window)
    video_frame.place(x=0, y=0, width=window_width, height=window_height // 2)

    text_frame = tk.Frame(window, bg='#474747')
    text_frame.place(x=0, y=window_height // 2, width=window_width // 2, height=window_height // 2)

    player = VideoPlayer(video_frame, fr"{base_path}\O.gif", window)

    scrollbar = tk.Scrollbar(text_frame, bg="#474747")
    scrollbar.pack(side="right", fill="y")

    textbox = tk.Text(text_frame, bg="#474747", fg="#FFFFFF", wrap="word", yscrollcommand=scrollbar.set, font=('Bell Gothic Std Black', 18))
    textbox.pack(fill="both", expand=True)
    scrollbar.config(command=textbox.yview, bg="#474747")

    # Define the UI frame
    UI_frame = tk.Frame(window, bg='#474747')
    UI_frame.place(x=window_width/2, y=0, width=window_width // 2, height=window_height)

    # Define the dimensions for Letter_update_frame
    frame_width = (window_width // 2) - (window_width // 30)
    frame_height = (window_height // 3) - (window_height // 30)

    # Calculate the x position to center Letter_update_frame in UI_frame
    x_position = ((window_width // 2) - frame_width) // 2

    # Define the Letter_update_frame
    Letter_update_frame = tk.Frame(UI_frame, bg="#474747")
    Letter_update_frame.place(
        x=x_position,
        y=(window_height // 30),
        width=frame_width,
        height=frame_height
    )

    # Add a border to visualize the frame
    Letter_update_frame.config(highlightbackground="white", highlightthickness=4)

    Letter_title = tk.Label(Letter_update_frame, bg ="#474747", fg = "#FFFFFF", text="Letter in current read:", font=('Bell Gothic Std Black', 18))
    Letter_title.place(x = 10, y = 10)

    Letter_show = tk.Text(Letter_update_frame, bg ="#474747", fg = "#FFFFFF", wrap="word", font=('Bell Gothic Std Black', 120))
    Letter_show.place(x = 250, y = 40, width=200, height=200)

    
    Speed_frame = tk.Frame(UI_frame, bg="#474747")
    Speed_frame.place(
        x=x_position,
        y= (2 * (window_height // 30)) + frame_height,
        width=frame_width,
        height=frame_height
    )

    Speed_frame.config(highlightbackground="white", highlightthickness=4)

    Speed_title = tk.Label(Speed_frame, bg ="#474747", fg = "#FFFFFF", text="Config Settings:", font=('Bell Gothic Std Black', 18))
    Speed_title.place(x = 10, y = 10)

        # Letter Pause
    letter_pause_label = tk.Label(Speed_frame, text="Letter Pause", bg ="#474747", fg = "#FFFFFF", font=('Bell Gothic Std Black', 12))
    letter_pause_label.place(x=frame_width/6, y=50)  # Place label above the entry
    letter_pause_control = tk.Entry(Speed_frame)
    letter_pause_control.place(x=frame_width/6, y=100)

    # Word Pause
    word_pause_label = tk.Label(Speed_frame, text="Word Pause", bg ="#474747", fg = "#FFFFFF", font=('Bell Gothic Std Black', 12))
    word_pause_label.place(x=frame_width/6, y=80)  # Place label above the entry
    word_pause_control = tk.Entry(Speed_frame)
    word_pause_control.place(x=frame_width/6, y=140)

    # Exit Word
    exit_word_label = tk.Label(Speed_frame, text="Exit Word", bg ="#474747", fg = "#FFFFFF", font=('Bell Gothic Std Black', 12))
    exit_word_label.place(x=frame_width/6, y=110)  # Place label above the entry
    exit_word_control = tk.Entry(Speed_frame)
    exit_word_control.place(x=frame_width/6, y=170)

    # Auto Save
    auto_save_label = tk.Label(Speed_frame, text="Auto Save", bg ="#474747", fg = "#FFFFFF", font=('Bell Gothic Std Black', 12))
    auto_save_label.place(x=4 * (frame_width/6), y=50)  # Place label above the entry
    auto_save_control = tk.Entry(Speed_frame)
    auto_save_control.place(x=4 * (frame_width/6), y=100)

    # Auto Launch GUI
    auto_launch_label = tk.Label(Speed_frame, text="Auto Launch GUI", bg ="#474747", fg = "#FFFFFF", font=('Bell Gothic Std Black', 12))
    auto_launch_label.place(x=4 * (frame_width/6), y=80)  # Place label above the entry
    auto_launch_control = tk.Entry(Speed_frame)
    auto_launch_control.place(x=4 * (frame_width/6), y=140)


    Set_speed = tk.Button(Speed_frame, text="Set variables", command=lambda: set_config_variables(letter_pause_control, word_pause_control, exit_word_control, auto_save_control, auto_launch_control))
    Set_speed.place(x = frame_height, y = 210)
    def update_text():
        try:
            new_text = text_queue.get_nowait()
            wordBacklog.clear()
            wordBacklog.extend(new_text.split())
            textbox.delete(1.0, tk.END)
            textbox.insert(tk.END, new_text)

        except queue.Empty:
            pass

        try:
            hand_sign = hand_queue.get_nowait()
            current_word = letter_queue.get_nowait()
            update_hand(hand_sign, current_word)
        except queue.Empty:
            pass

        window.after(100, update_text)

    def update_hand(hand_sign, current_word):
        video_path = update_letter(hand_sign)
        print(video_path)
        player.set_path(video_path)
        Letter_show.delete(1.0, tk.END)  # Clear the previous hand_sign
        Letter_show.insert(tk.END, hand_sign.upper())  # Insert the current hand_sign
        highlight_text(current_word)

    def highlight_text(current_word):
        textbox.tag_remove("highlight", "1.0", tk.END)

        start_index = textbox.search(current_word, "1.0", tk.END)
        if start_index:
            end_index = f"{start_index}+{len(current_word)}c"
            textbox.tag_add("highlight", start_index, end_index)
            textbox.tag_config("highlight", background="yellow", foreground="black")

        # Schedule the next update
        window.after(100, update_text)

    window.after(100, update_text)
    window.mainloop()


def GUI_APP(text_queue, wordBacklog, hand_queue, letter_queue):
    populate_queue(text_queue, wordBacklog)
    GUI(text_queue, hand_queue, letter_queue, wordBacklog)
